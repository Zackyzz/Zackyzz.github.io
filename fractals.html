<!DOCTYPE html>
<html lang="en">

<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-2X6KL0PLK8"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-2X6KL0PLK8');
    </script>
    <meta charset="utf-8">
    <title>Fractal Compression</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@300&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
    <div class="dark-mode-switch">
        <input type="checkbox" id="darkModeToggle">
        <label for="darkModeToggle"></label>
    </div>

    <nav class="sidebar" id="sidebar">
        <div class="handle" id="handle"></div>
        <ul class = "nav-list">
            <li class = "first-nav-item"><a href="index.html">Home</a></li>
            <li class = "first-nav-item"><a href="quantum.html">Quantum Computing</a></li>
            <li class = "first-nav-item"><a href="feynman.html">Feynman's Trick</a></li>
            <li class = "first-nav-item"><a class="active" href="fractals.html">Fractal Compression</a></li>
            <li class = "first-nav-item"><a href="about.html">About</a></li>
        </ul>
    </nav>

    <div class="page-content">
        <h1>
            Fractal Compression
        </h1>

        <p>
            The first step would be to actually load the image.
        </p>

        <p>
            After we got the image's values into a matrix we can proceed with retrieving the ranges in a list, but also remembering to precompute \(r_i\) and \(r_i^2\).
        </p>

        <div id = "codeBox">
            <button onclick="showCode('racket')">Racket</button>
            <button onclick="showCode('julia')">Julia</button>

            <pre id="racketCode" class="codeBlock"><code>
                (define (get-ranges matrix [nr 64] [size 8] [step 8])
                 (apply
                  append
                   (for/list ([i (in-range 0 (* nr step) step)])
                    (for/list ([j (in-range 0 (* nr step) step)])
                        (define sum 0)
                        (define sum^2 0)
                        (define block
                        (for/vector ([a (in-range i (+ i size))])
                            (for/vector ([b (in-range j (+ j size))])
                            (define bi (matrix-get matrix a b))
                            (set! sum (+ sum bi))
                            (set! sum^2 (+ sum^2 (sqr bi)))
                            bi)))
                        (list (vector->list (apply vector-append (vector->list block))) sum sum^2)))))
            </code></pre>

            <pre id="juliaCode" class="codeBlock"><code>
                #Julia indexes are starting from 1 not 0
                ranges = []
                for w in 1:S:WIDTH-S+1
                    for h in 1:S:HEIGHT-S+1
                        temporary_range = img_vals[w:w+S-1, h:h+S-1]
                        ri = sum(temporary_range)
                        ri2 = sum(temporary_range.^2)
                        push!(ranges, [temporary_range, ri, ri2])
                    end
                end
            </code></pre>
        </div>

        <p>
            Next up are the domains, which are somewhat similarly to the ranges with 2 exceptions: the blocks initially are 16x16 which must be downscaled (by averaging every 2x2 group of pixels) and also by taking the eight isometries into account.
        </p>

        <div id = "codeBox">
            <button onclick="showCode('racket')">Racket</button>
            <button onclick="showCode('julia')">Julia</button>

            <pre id="racketCode" class="codeBlock"><code>
                (define (make-isometry matrix iso [size 8])
                (for/vector ([i size])
                  (for/vector ([j size])
                    (cond
                      [(= iso 0) (matrix-get matrix i j)]
                      [(= iso 1) (matrix-get matrix i (- size 1 j))]
                      [(= iso 2) (matrix-get matrix (- size 1 i) j)]
                      [(= iso 3) (matrix-get matrix (- size 1 j) (- size 1 i))]
                      [(= iso 4) (matrix-get matrix j i)]
                      [(= iso 5) (matrix-get matrix (- size 1 j) i)]
                      [(= iso 6) (matrix-get matrix (- size 1 i) (- size 1 j))]
                      [(= iso 7) (matrix-get matrix j (- size 1 i))]))))
                    
                (define (get-domains matrix [nr 63] [size 16] [step 8])
                (apply
                append
                (for/list ([i (in-range 0 (* nr step) step)])
                (apply
                    append
                    (for/list ([j (in-range 0 (* nr step) step)])
                    (define sum 0)
                    (define sum^2 0)
                    (define block
                        (for/vector ([a (in-range i (+ i size) 2)])
                        (for/vector ([b (in-range j (+ j size) 2)])
                            (define bi
                            (quotient (+ (matrix-get matrix a b)
                                        (matrix-get matrix a (add1 b))
                                        (matrix-get matrix (add1 a) b)
                                        (matrix-get matrix (add1 a) (add1 b)))
                                        4))
                            (set! sum (+ sum bi))
                            (set! sum^2 (+ sum^2 (sqr bi)))
                            bi)))
                    (for/list ([i 8])
                        (list (vector->list (apply vector-append (vector->list (make-isometry block i))))
                            sum sum^2)))))))
            </code></pre>

            <pre id="juliaCode" class="codeBlock"><code>
                function downscale_block(block)
                    downscaled_block = zeros(S,S)
                        for i in 1:S
                            for j in 1:S
                                downscaled_block[i,j] = div(block[2*i, 2*j] + block[2*i-1, 2*j] + block[2*i, 2*j-1] + block[2*i-1, 2*j-1], 4)
                            end
                        end
                    return downscaled_block
                end

                function apply_isometry(block, index)
                    isometries = [
                        block,
                        reverse(transpose(block), dims=2),
                        reverse(reverse(block, dims=1), dims=2),
                        reverse(transpose(block), dims=1),
                        reverse(block, dims=1),
                        reverse(block, dims=2),
                        transpose(block),
                        transpose(reverse(reverse(block, dims=1), dims=2))
                    ]
                    return isometries[index]
                end

                domains = []
                for w in 1:S:WIDTH-2*S+1
                    for h in 1:S:HEIGHT-2*S+1
                        domain = downscale_block(img_vals[w: w+2*S-1, h:h+2*S-1])
                        for i in 1:8
                            transformed_domain = apply_isometry(domain, i)
                            di = sum(transformed_domain)
                            di2 = sum(transformed_domain.^2)
                            push!(domains, [transformed_domain, di, di2])
                        end
                    end
                end
            </code></pre>
        </div>

    </div>

    <script src="switch_code.js"></script>
    <script src="main.js"></script>
    <script src="dark_mode.js"></script>
    <script src="hide_sidebar.js"></script>
</body>

</html>